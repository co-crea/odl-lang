import pytest

from odl.types import NodeField
from odl.compiler.rules import syntax
from odl.compiler.exceptions import OdlCompilationError

class TestSyntaxRules:
    
    # --- 既存テスト (修正済み) ---

    def test_tc_syntax_001_mandatory_fields_per_opcode(self):
        """TC-RULES-SYNTAX-001: OpCodeごとの必須フィールドチェック"""
        # Case 1: loop without contents
        node = {NodeField.STACK_PATH: "n1", NodeField.OPCODE: "loop", NodeField.PARAMS: {"count": 3}}
        with pytest.raises(OdlCompilationError, match="Missing required field 'contents'"):
            syntax.validate(node)

        # Case 2: fan_out without required fields
        node = {NodeField.STACK_PATH: "n2", NodeField.OPCODE: "fan_out", NodeField.PARAMS: {}}
        with pytest.raises(OdlCompilationError, match="Missing required field 'source'"):
            syntax.validate(node)

    def test_tc_syntax_002_parameter_type_constraints(self):
        """TC-RULES-SYNTAX-002: パラメータの型制約チェック"""
        # loop count must be int
        node = {
            NodeField.OPCODE: "loop",
            NodeField.PARAMS: {"count": "infinite"}, # String is invalid
            NodeField.CONTENTS: {NodeField.OPCODE: "worker", NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: "doc"}} # wiring追加
        }
        with pytest.raises(OdlCompilationError, match="must be integer"):
            syntax.validate(node)

    def test_tc_syntax_003_recursive_validation(self):
        """TC-RULES-SYNTAX-003: 再帰的な検証"""
        root = {
            NodeField.OPCODE: "serial",
            NodeField.CHILDREN: [
                {
                    NodeField.OPCODE: "loop",
                    # contents missing here
                }
            ]
        }
        with pytest.raises(OdlCompilationError, match="Missing required field"):
            syntax.validate(root)

    def test_tc_syntax_004_contextual_constraint_nested_fanout(self):
        """TC-RULES-SYNTAX-004: fan_outのネスト禁止"""
        root = {
            NodeField.OPCODE: "fan_out",
            "source": "list", "item_key": NodeField.STACK_PATH,
            NodeField.CONTENTS: {
                NodeField.OPCODE: "serial",
                NodeField.CHILDREN: [
                    {
                        NodeField.OPCODE: "fan_out", # Nested fan_out (NG)
                        "source": "sub", "item_key": "sub_id",
                        NodeField.CONTENTS: {NodeField.OPCODE: "worker", NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: "out"}}
                    }
                ]
            }
        }
        with pytest.raises(OdlCompilationError, match="Nested fan_out is not allowed"):
            syntax.validate(root)

    def test_tc_syntax_005_naming_convention(self):
        """TC-RULES-SYNTAX-005: 文書名（Wiring I/O）の命名規則違反を検知し、#の使用ルールを検証する"""
        
        # Case A: 禁止文字 (Forbidden Characters)
        # 修正: # は別途テストするため、ここではそれ以外をチェック
        invalid_chars = [
            "Invalid:Name", 
            "Invalid/Name", 
            "Invalid{Name}", 
            "Invalid@Name"
        ]
        for name in invalid_chars:
            node = {
                NodeField.STACK_PATH: "n1", NodeField.OPCODE: "worker",
                NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: name}
            }
            with pytest.raises(OdlCompilationError, match="Invalid character"):
                syntax.validate(node)

        # Case B: 予約語ルール違反 (Reserved Names)
        invalid_reserved = [
            "__AutoGenerated", # Prefix __
            "User__Data",      # Infix __
            "Data__",          # Suffix __
            "_PrivateVar",     # Prefix _
        ]
        for name in invalid_reserved:
            node = {
                NodeField.STACK_PATH: "n2", NodeField.OPCODE: "worker",
                NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: name}
            }
            with pytest.raises(OdlCompilationError, match="are reserved"):
                syntax.validate(node)

        # Case C: # の不正な使用 (Explicit ID Rules)
        invalid_hashes = [
            "Name##DoubleHash", # 2個以上は禁止
            "#Name",            # LocalNameが空
            "Name#",            # Suffixが空
        ]
        for name in invalid_hashes:
            node = {
                NodeField.STACK_PATH: "n_hash", NodeField.OPCODE: "worker",
                NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: name}
            }
            # エラーメッセージは個別に検証しても良いが、ここでは SyntaxRule エラーが出ることを確認
            with pytest.raises(OdlCompilationError):
                syntax.validate(node)

        # Case D: 許可される文字 (Valid Names)
        # 修正: 明示的ID指定パターン (Name#ID) を追加
        valid_names = [
            "Valid_Name", 
            "Valid-Name-123", 
            "My_Private_Like_Name", # 中間のシングルアンダースコアはOK
            "企画書",           # Kanji
            "ミーティングログ",   # Katakana
            "設計書#Ver1.0",    # Explicit ID Binding (OK)
            "Result#part_A"     # Explicit ID Binding with underscore (OK)
        ]
        for name in valid_names:
            node = {
                NodeField.STACK_PATH: "ok", NodeField.OPCODE: "worker",
                NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: name}
            }
            # エラーが発生しないこと
            syntax.validate(node)

    # --- 新規追加テスト (New Coverage) ---

    def test_tc_syntax_006_worker_mandatory_fields(self):
        """TC-RULES-SYNTAX-006: Workerの必須フィールド(wiring, inputs, output)チェック"""
        
        # Case A: Missing wiring block
        node_no_wiring = {NodeField.OPCODE: "worker", NodeField.STACK_PATH: "w1"}
        with pytest.raises(OdlCompilationError, match="Missing or empty 'wiring'"):
            syntax.validate(node_no_wiring)

        # Case B: Empty wiring block
        node_empty_wiring = {NodeField.OPCODE: "worker", NodeField.STACK_PATH: "w2", NodeField.WIRING: {}}
        with pytest.raises(OdlCompilationError, match="Missing or empty 'wiring'"):
            syntax.validate(node_empty_wiring)

        # Case C: Missing inputs
        node_no_inputs = {
            NodeField.OPCODE: "worker", 
            NodeField.WIRING: {NodeField.OUTPUT: "Doc"}
        }
        with pytest.raises(OdlCompilationError, match="Worker must have 'inputs'"):
            syntax.validate(node_no_inputs)

        # Case D: Missing output
        node_no_output = {
            NodeField.OPCODE: "worker", 
            NodeField.WIRING: {NodeField.INPUTS: []}
        }
        with pytest.raises(OdlCompilationError, match="Worker must have 'output'"):
            syntax.validate(node_no_output)

        # Case E: Valid Worker
        node_valid = {
            NodeField.OPCODE: "worker",
            NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: "Doc"}
        }
        syntax.validate(node_valid)

    def test_tc_syntax_007_ensemble_duplicate_check(self):
        """TC-RULES-SYNTAX-007: Ensemble内のGenerator重複定義チェック"""
        
        # Case A: Duplicate Generators
        node_dup = {
            NodeField.OPCODE: "ensemble",
            NodeField.PARAMS: {
                "generators": ["AgentA", "AgentB", "AgentA"], # AgentA is duplicate
                "samples": 1,
                "consolidator": "Boss"
            },
            NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: "Idea"}
        }
        with pytest.raises(OdlCompilationError, match="Duplicate generator agent IDs"):
            syntax.validate(node_dup)

        # Case B: Valid Generators
        node_valid = {
            NodeField.OPCODE: "ensemble",
            NodeField.PARAMS: {
                "generators": ["AgentA", "AgentB"],
                "samples": 1,
                "consolidator": "Boss"
            },
            NodeField.WIRING: {NodeField.INPUTS: [], NodeField.OUTPUT: "Idea"}
        }
        syntax.validate(node_valid)

    def test_tc_syntax_008_fanout_parallel_constraints(self):
        """TC-RULES-SYNTAX-008: Fan-out(Parallel)配下での順序依存修飾子(@prev)の使用禁止"""
        
        # Case A: Parallel Strategy with @prev (Error)
        root_invalid = {
            NodeField.OPCODE: "fan_out",
            NodeField.PARAMS: {"strategy": "parallel", "source": "L", "item_key": "K"},
            NodeField.CONTENTS: {
                NodeField.OPCODE: "worker",
                NodeField.WIRING: {
                    NodeField.INPUTS: ["Doc@prev"], # Forbidden in parallel
                    NodeField.OUTPUT: "Result"
                }
            }
        }
        with pytest.raises(OdlCompilationError, match="Invalid modifier '@prev'"):
            syntax.validate(root_invalid)

        # Case B: Serial Strategy with @prev (Allowed)
        root_valid_serial = {
            NodeField.OPCODE: "fan_out",
            NodeField.PARAMS: {"strategy": "serial", "source": "L", "item_key": "K"},
            NodeField.CONTENTS: {
                NodeField.OPCODE: "worker",
                NodeField.WIRING: {
                    NodeField.INPUTS: ["Doc@prev"],
                    NodeField.OUTPUT: "Result"
                }
            }
        }
        syntax.validate(root_valid_serial)

        # Case C: Parallel Strategy without modifiers (Allowed)
        root_valid_parallel = {
            NodeField.OPCODE: "fan_out",
            NodeField.PARAMS: {"strategy": "parallel", "source": "L", "item_key": "K"},
            NodeField.CONTENTS: {
                NodeField.OPCODE: "worker",
                NodeField.WIRING: {
                    NodeField.INPUTS: ["Doc"], # OK
                    NodeField.OUTPUT: "Result"
                }
            }
        }
        syntax.validate(root_valid_parallel)